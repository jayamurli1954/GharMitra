
Note On Render Cloud hosting Precaution
---

## âœ… What â€œEphemeral Filesystemâ€ Actually Means

![Image](https://gvisor.dev/assets/images/2024-09-23-dangerzone-with-gvisor-annotated.svg)

![Image](https://miro.medium.com/v2/resize%3Afit%3A2000/1%2AF31zzt_ErUIbD_aqFjh4SA.jpeg)

![Image](https://docs.ataccama.com/one/14.5.x/ataccama-one-paas/_images/backup-and-restore-architecture-paas-restore-architecture-azure.png)

On most **PaaS platforms** (including **Render**, Railway, Fly.io, Heroku):

> **The disk attached to your running app is TEMPORARY.**

### What happens:

* App restarts (deploy, crash, scale, maintenance)
* Container is recreated
* **Local files are wiped**
* `/data`, `/tmp`, `./db.sqlite` â†’ âŒ gone

---

## â— The Statement Is TRUE If You Do This

```text
âŒ Use SQLite
âŒ Store uploads on local disk
âŒ Assume files survive restarts
```

Example:

```python
sqlite:///app.db   âŒ DANGEROUS on Render
```

You **will lose data**.

---

## ğŸŸ¢ But Hereâ€™s the Important Part (Founder-Safe)

> **This is NOT a problem if you architect correctly.**

Render is designed to be used with:

* Managed databases
* External storage
* Stateless backend services

---

## ğŸ—ï¸ Correct Backend Architecture (Safe on Render)

### âœ… What to use instead

| Data Type       | Correct Storage        |
| --------------- | ---------------------- |
| App data        | Render PostgreSQL      |
| Accounting data | Render PostgreSQL      |
| User uploads    | S3-compatible storage  |
| Logs            | External / Render logs |
| Cache           | Redis (optional)       |

---

## ğŸŸ¢ What GharMitra & LegalMitra Should Do

### 1ï¸âƒ£ **DO NOT use SQLite in production**

SQLite is OK **only** for:

* Local development
* Unit tests
* Demo on laptop

---

### 2ï¸âƒ£ **Use Managed PostgreSQL (This is persistent)**

```text
âœ” Render PostgreSQL = persistent
âœ” Daily backups
âœ” Survives restarts
âœ” Survives redeploys
```

This is how **real SaaS apps** work.

---

### 3ï¸âƒ£ **Use External Object Storage for Files**

For:

* PDF bills
* Receipts
* Legal documents

Use:

* AWS S3
* Cloudflare R2
* OCI Object Storage (later)

---

## ğŸ” Why This Is Actually a GOOD Thing

Ephemeral services mean:

| Benefit         | Why it matters          |
| --------------- | ----------------------- |
| No state in app | Easy scaling            |
| Easy redeploy   | No corruption           |
| Crash-safe      | App restart â‰  data loss |
| Security        | No stale data on disk   |

This is **cloud-native best practice**, not a limitation.

---

## ğŸ”´ Where People Go Wrong (Common Startup Mistake)

They:

* Pick Render/Railway
* Use SQLite
* Upload files locally
* Lose data
* Blame the platform âŒ

The **architecture** is wrong, not the platform.

---

## ğŸ§  Final Verdict (Very Important)

> âœ… The statement is TRUE
> âŒ It is NOT a reason to avoid Render
> âœ… It is a reason to avoid SQLite & local storage in production

For **GharMitra (accounting)**:

* SQLite would be **professionally unacceptable**
* PostgreSQL is **mandatory**

For **LegalMitra (legal SaaS)**:

* Same rule applies

---

## ğŸŸ¢ Safe Setup Checklist (Use This)

âœ” Backend = Stateless
âœ” DB = Managed PostgreSQL
âœ” Files = Object storage
âœ” No critical data on local disk
âœ” Backup enabled

If you follow this, **Render is 100% safe and production-ready**.










Perfect. Below is a **complete, production-grade implementation guide** for **GharMitra**, covering **all 4 items end-to-end**, written so you can **hand it directly to a developer** (or follow it yourself).

This is **how serious SaaS accounting systems are built**.

---

# 1ï¸âƒ£ Exact **Render (Backend) + Vercel (Frontend)** Deployment Steps

---

## ğŸ”¹ A. Backend Deployment â€” **Render + FastAPI + PostgreSQL**

### Step 1: Prepare Backend Repo

Your FastAPI repo must have:

```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ main.py
â”‚   â”œâ”€â”€ db.py
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ routers/
â”‚   â””â”€â”€ core/
â”œâ”€â”€ requirements.txt
â””â”€â”€ render.yaml (optional)
```

`requirements.txt`

```
fastapi
uvicorn
sqlalchemy
psycopg2-binary
alembic
python-jose
passlib[bcrypt]
```

---

### Step 2: Create PostgreSQL on Render

1. Go to **Render**
2. New â†’ **PostgreSQL**
3. Choose:

   * Plan: Starter (for pilot)
   * Region: any
4. Copy **DATABASE_URL**

---

### Step 3: Create Web Service (FastAPI)

1. Render â†’ New â†’ Web Service

2. Connect GitHub repo

3. Settings:

   * Build Command:

     ```
     pip install -r requirements.txt
     ```
   * Start Command:

     ```
     uvicorn app.main:app --host 0.0.0.0 --port 10000
     ```

4. Add Environment Variables:

```
DATABASE_URL=postgresql+psycopg2://...
JWT_SECRET=****
ENV=production
```

---

### Step 4: FastAPI DB Config (Production-safe)

```python
# db.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

engine = create_engine(
    DATABASE_URL,
    pool_pre_ping=True
)

SessionLocal = sessionmaker(bind=engine)
```

---

## ğŸ”¹ B. Frontend Deployment â€” **Vercel + React 18**

### Step 1: Frontend Config

In React:

```env
VITE_API_BASE_URL=https://gharmitra-api.onrender.com
```

---

### Step 2: Deploy to **Vercel**

1. Import GitHub repo
2. Framework preset: React / Vite
3. Build command:

```
npm run build
```

4. Output:

```
dist
```

---

### Step 3: CORS (Backend)

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://gharmitra.vercel.app"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

---

# 2ï¸âƒ£ Convert **SQLite â†’ PostgreSQL** Safely (No Rewrite)

---

## ğŸ”¹ A. Update SQLAlchemy Models

âœ” **No change needed** if models are portable
Avoid SQLite-specific types.

---

## ğŸ”¹ B. Alembic Migration (Recommended)

### Step 1: Init Alembic

```bash
alembic init alembic
```

### Step 2: Set DB URL

```ini
sqlalchemy.url = postgresql+psycopg2://...
```

---

### Step 3: Auto-generate Schema

```bash
alembic revision --autogenerate -m "initial schema"
alembic upgrade head
```

PostgreSQL schema is now live.

---

## ğŸ”¹ C. Data Migration (One-time)

```python
# migrate.py
sqlite_engine = create_engine("sqlite:///old.db")
pg_engine = create_engine(POSTGRES_URL)

# read from sqlite â†’ write to postgres
```

Run once, verify counts, then **freeze SQLite forever**.

---

# 3ï¸âƒ£ DB-Level Accounting Safety Constraints (MANDATORY)

This is what makes **GharMitra superior**.

---

## ğŸ” A. Voucher Integrity (Debit = Credit)

```sql
CREATE OR REPLACE FUNCTION check_voucher_balance()
RETURNS trigger AS $$
BEGIN
  IF (
    SELECT COALESCE(SUM(debit),0) - COALESCE(SUM(credit),0)
    FROM journal_lines
    WHERE voucher_id = NEW.voucher_id
  ) <> 0 THEN
    RAISE EXCEPTION 'Debit and Credit mismatch';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## ğŸ” B. Prevent Cross-Society Leakage

```sql
ALTER TABLE journal_lines
ADD CONSTRAINT society_match
CHECK (society_id IS NOT NULL);
```

All tables **MUST have society_id**.

---

## ğŸ” C. Lock Closed Periods

```sql
ALTER TABLE journal_lines
ADD CONSTRAINT no_post_closed_period
CHECK (posting_date > (SELECT locked_until FROM society));
```

---

## ğŸ” D. Prevent Direct P&L in Balance Sheet

```sql
CREATE VIEW balance_sheet_accounts AS
SELECT *
FROM ledger
WHERE account_type IN ('ASSET','LIABILITY');
```

---

# 4ï¸âƒ£ Zero-Downtime Migration Plan (SQLite â†’ PostgreSQL)

This is **clean, safe, and professional**.

---

## ğŸŸ¢ Phase 1: Dual-Write (Temporary)

* App writes to:

  * SQLite (old)
  * PostgreSQL (new)

Duration: 1â€“2 days

---

## ğŸŸ¡ Phase 2: Read from PostgreSQL

* Switch API reads to PostgreSQL
* SQLite becomes **read-only**

---

## ğŸ”µ Phase 3: Verification

* Compare:

  * Trial Balance
  * Member dues
  * Bank balances

If mismatch â†’ block switch.

---

## ğŸ”´ Phase 4: Cutover

* Disable SQLite writes
* Remove SQLite code
* Backup PostgreSQL
* Tag release

âœ” **No downtime**
âœ” **No data loss**
âœ” **Auditor-safe**

---

# ğŸ§  Final Founder Verdict (Lock This In)

If you follow **all 4 steps exactly**:

âœ… GharMitra becomes **production-grade accounting SaaS**
âœ… Render + Vercel is **more than sufficient**
âœ… SQLite risk is completely eliminated
âœ… Migration path to OCI remains open

> **This is the correct architecture. Do not compromise further.**

---













---Short answer first (very important):

> âŒ **This architecture is NOT OK for GharMitra in real usage**
> âœ… **You should shift to Render (backend) + Vercel or Render Static (frontend)**

Your **framework choices are good**, but **one core decision (SQLite in cloud)** makes it **unsafe for an accounting product**.

Let me break this down **calmly and decisively**, so you know *exactly* what to change and *what not to touch*.

---

## ğŸ” Your Current Architecture â€” Whatâ€™s GOOD vs RISKY

### âœ… GOOD (Keep these)

* **FastAPI (Python)** â†’ excellent choice
* **SQLAlchemy ORM** â†’ correct abstraction
* **OAuth2 + JWT** â†’ production-grade
* **React 18 + react-native-web** â†’ smart, future-proof
* **SPA frontend** â†’ perfectly fine

So **70% of your design is solid** ğŸ‘

---

### âŒ CRITICAL PROBLEM (Must Fix)

#### ğŸš¨ SQLite in Cloud for GharMitra

SQLite is:

* Single-file
* File-lock based
* Designed for **local apps**, not multi-user SaaS

On cloud platforms (Railway / Netlify / Render free tiers):

> ğŸ”¥ **Local files are ephemeral**
> ğŸ”¥ App restarts = DB file deleted
> ğŸ”¥ Concurrent writes = corruption risk

For **accounting software**, this is **professionally unacceptable**.

âš ï¸ One restart on billing day = **data loss**

---

## ğŸ—ï¸ Why This Is Especially Dangerous for GharMitra

GharMitra deals with:

* Double-entry accounting
* Trial balance integrity
* Audit & AGM reports
* Legal liability for wrong balances

Using SQLite means:

* âŒ No safe concurrency
* âŒ No crash recovery
* âŒ No audit confidence
* âŒ No future scale

**Auditors will reject it.**

---

## âœ… Correct Architecture for GharMitra (Minimal Change)

You do **NOT** need a rewrite.

Just make **2 surgical changes** ğŸ‘‡

---

## ğŸŸ¢ Recommended Production Architecture

![Image](https://miro.medium.com/v2/resize%3Afit%3A1400/1%2AMdf8g_kE3873TNag66NMqg.jpeg)

![Image](https://miro.medium.com/1%2ABxNgaYmYs2YGg5XB8hmmiA.png)

![Image](https://d2908q01vomqb2.cloudfront.net/1b6453892473a467d07372d45eb05abc2031647a/2022/11/04/micro-frontends3.png)

![Image](https://www.workingsoftware.dev/content/images/size/w1200/2022/12/Untitled-2022-05-21-1141.png)

### Backend (Change 1 thing)

* **Framework:** FastAPI âœ… (keep)
* **Database:** âŒ SQLite â†’ âœ… PostgreSQL
* **ORM:** SQLAlchemy âœ… (keep)
* **Hosting:** **Render**

Why Render?

* Persistent managed PostgreSQL
* Predictable billing
* No DevOps headache
* Perfect for pilot societies

---

### Frontend (Your choice is already good)

* **Framework:** React 18 + react-native-web âœ…
* **Hosting options:**

  * **Vercel** â†’ best UX
  * Render Static â†’ cheapest

Both work perfectly with react-native-web.

---

## ğŸ”„ What Exactly You Should Change (Concrete)

### âŒ Current DB config (dangerous)

```python
sqlite:///gharmitra.db
```

### âœ… Safe production config

```python
postgresql+psycopg2://user:password@host:5432/gharmitra
```

No other logic change required.

---

## ğŸ’° Cost Reality (Pilot Phase)

For **5â€“6 societies, 3 months**:

| Component   | Platform        | Monthly â‚¹        |
| ----------- | --------------- | ---------------- |
| Backend API | Render          | 750â€“1,000        |
| PostgreSQL  | Render          | 700â€“2,000        |
| Frontend    | Vercel / Render | 0                |
| **Total**   |                 | **â‚¹1,700â€“3,000** |

Thatâ€™s **cheaper than one society AGM expense**.

---

## ğŸ§  Founder-Level Verdict (Very Clear)

### âŒ Do NOT do this

* SQLite on Railway/Netlify for production
* Local DB files
* â€œWeâ€™ll migrate laterâ€ mindset

### âœ… DO THIS

* FastAPI + PostgreSQL
* Render backend
* Vercel or Render frontend
* Stateless backend

> **If GharMitra handles money, SQLite must go. Period.**

---

## ğŸŸ¢ Final Recommendation (Lock This)

**For GharMitra:**

* Backend â†’ **Render + PostgreSQL**
* Frontend â†’ **Vercel** (or Render Static if cost-first)
* SQLite â†’ **ONLY for local dev**

Your **react-native-web decision is excellent** â€” keep it.

---







